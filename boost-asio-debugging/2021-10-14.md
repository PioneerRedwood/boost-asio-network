# 2021-10-14

## ë¬¸ì œì  #1 tr1::bad_weak_ptr

boost ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ asio ì“°ê¸° ì „ê¹Œì§€ëŠ” ì „í˜€ ì“°ì§€ ì•Šì•˜ë‹¤. C++ ìµœëŒ€ ê·œëª¨ì˜ ìƒìš© ë¼ì´ë¸ŒëŸ¬ë¦¬ì¸ ë™ì‹œì— C++ í‘œì¤€ ìœ„ì›íšŒì—ë„ ì˜í–¥ë ¥ì„ ë°œíœ˜í•œë‹¤ëŠ” ë§ì„ ìì£¼ ë“£ê³¤ í–ˆë‹¤. ê·¸ë˜ì„œì¸ì§€ boost ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì˜ì‹¬ ì—†ì´ ì‹ ë¢°í–ˆë‹¤. ì—¬ëŸ¬ ì°¸ê³  ì½”ë“œë“¤ì„ ë³´ë©´ì„œ ë‚´ê²ƒìœ¼ë¡œ ë§Œë“œëŠ” ê²ƒì´ ê³§ í•™ìŠµì´ë©° ê²½í—˜ì´ê³  ì‹¤ë ¥ì´ ë˜ë¦¬ë¼ê³  ë¯¿ëŠ” ë‹¨ìˆœí•œ ì½”ë”ì—ê² ì–¸ì  ê°€ëŠ” ì§ë©´í•˜ê²Œ ë  ì¼ì´ê¸°ë„ í–ˆë‹¤. 

```C++
template<typename T>
class tcp_connection
    // boost::enable_shared_from_this<> ì‚¬ìš©
	: public boost::enable_shared_from_this<tcp_connection<T>>
	, boost::noncopyable
...
// tcp_connectionì„ ìƒì†ë°›ëŠ” login_conn
template<typename T>
class login_conn : public tcp_connection<T>
...
// async_accept .. std::shared_ptr<> ì‚¬ìš©?
std::shared_ptr<login_conn<T>> conn_ = std::make_shared<login_conn<T>>(context_, std::move(socket), curr_id_, period_); // RUNTIME ERROR tr1::bad_weak_ptr!!
```

ë‘ê°€ì§€ë¥¼ í˜¼ìš©í•´ì„œ ì‚¬ìš©í•œ ê²°ê³¼ tr1::bad_weak_ptr ì—ëŸ¬ë¥¼ ë°œê²¬í–ˆê³  ì´ë¥¼ ë””ë²„ê¹…í•˜ëŠ” ë°ì— ì ì§€ ì•Šì€ ì‹œê°„ì„ ë“¤ì˜€ë‹¤. std::enable_shared_from_thisì™€ boost::enable_shared_from_this ë‘˜ì˜ ì‚¬ì–‘ì´ ë‹¤ë¥¸ ì—°ìœ ë¡œ ë°œìƒí•œ ì˜¤ë¥˜ì˜€ë‹¤. boostì™€ ê°™ì€ ìƒìš© ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” í¸ë¦¬í•˜ì§€ë§Œ ë™ì‹œì— ê°œë°œìì—ê²Œ ì˜¤íˆë ¤ ë…ì´ ë  ìˆ˜ ìˆìŒì„ ëŠê¼ˆë‹¤. low-level ìˆ˜ì¤€ì˜ ë¡œì§ì— ê´€ì‹¬ì„ ë‘ê³  ì–´ë–¤ ë°©ì‹ìœ¼ë¡œ êµ¬í˜„ëëŠ”ì§€ ì² ì €í•˜ê²Œ í™•ì¸í•´ì•¼ê² ë‹¤. 

### ì¶”ì‹ 

ì–´ì©Œë©´ boost, std ë¬¸ì œê°€ ì•„ë‹ˆë¼ boost::noncopyableì„ ìƒì†í•œ íƒ“ì¼ ìˆ˜ë„ ìˆê² ë‹¤ë¼ëŠ” ìƒê°ì´ ë¬¸ë“ ë“ ë‹¤. ì™„ë²½í•œ ì›ì¸ì„ ì°¾ì§€ ëª»í•´ì„œì¸ ê²ƒ ê°™ë‹¤.

### ì°¸ê³  ì§ˆë¬¸ë“¤

1. https://stackoverflow.com/questions/13267908/what-is-the-difference-between-boost-smart-pointers-and-std-smart-pointers/13267953
2. https://stackoverflow.com/questions/4902313/difference-between-boostshared-ptr-and-stdshared-ptr-from-the-standard-memo
3. https://stackoverflow.com/questions/1086798/differences-between-different-flavours-of-shared-ptr



## 2021-10-12 ì˜ë¬¸ì  --> [issue #2](https://github.com/PioneerRedwood/boost-asio-network/issues/2)ë¡œ

udp::socketì˜ async_send_to() ì „ì†¡ ì‹œ ë¹„ë™ê¸° ì“°ê¸° ì´í›„ ì „ì†¡í•œ ë°”ì´íŠ¸ì˜ í¬ê¸°ê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì „ë‹¬í•œ ë©”ì‹œì§€ì˜ í¬ê¸°ì™€ ë‹¤ë¥´ë‹¤. 

```C++
/// Start an asynchronous send.
  /**
   * This function is used to asynchronously send a datagram to the specified
   * remote endpoint. The function call always returns immediately.
   *
   * @param buffers One or more data buffers to be sent to the remote endpoint.
   * Although the buffers object may be copied as necessary, ownership of the
   * underlying memory blocks is retained by the caller, which must guarantee
   * that they remain valid until the handler is called.
   *
   * @param destination The remote endpoint to which the data will be sent.
   * Copies will be made of the endpoint as required.
   *
   * @param handler The handler to be called when the send operation completes.
   * Copies will be made of the handler as required. The function signature of
   * the handler must be:
   * @code void handler(
   *   const boost::system::error_code& error, // Result of operation.
   *   std::size_t bytes_transferred           // Number of bytes sent.
   * ); @endcode
   * Regardless of whether the asynchronous operation completes immediately or
   * not, the handler will not be invoked from within this function. On
   * immediate completion, invocation of the handler will be performed in a
   * manner equivalent to using boost::asio::post().
   *
   * @par Example
   * To send a single data buffer use the @ref buffer function as follows:
   * @code
   * boost::asio::ip::udp::endpoint destination(
   *     boost::asio::ip::address::from_string("1.2.3.4"), 12345);
   * socket.async_send_to(
   *     boost::asio::buffer(data, size), destination, handler);
   * @endcode
   * See the @ref buffer documentation for information on sending multiple
   * buffers in one go, and how to use it with arrays, boost::array or
   * std::vector.
   *
   * @par Per-Operation Cancellation
   * On POSIX or Windows operating systems, this asynchronous operation supports
   * cancellation for the following boost::asio::cancellation_type values:
   *
   * @li @c cancellation_type::terminal
   *
   * @li @c cancellation_type::partial
   *
   * @li @c cancellation_type::total
   */
  template <typename ConstBufferSequence,
      BOOST_ASIO_COMPLETION_TOKEN_FOR(void (boost::system::error_code,
        std::size_t)) WriteHandler
          BOOST_ASIO_DEFAULT_COMPLETION_TOKEN_TYPE(executor_type)>
  BOOST_ASIO_INITFN_AUTO_RESULT_TYPE(WriteHandler,
      void (boost::system::error_code, std::size_t))
  async_send_to(const ConstBufferSequence& buffers,
      const endpoint_type& destination,
      BOOST_ASIO_MOVE_ARG(WriteHandler) handler
        BOOST_ASIO_DEFAULT_COMPLETION_TOKEN(executor_type))
  {
    return async_initiate<WriteHandler,
      void (boost::system::error_code, std::size_t)>(
        initiate_async_send_to(this), handler, buffers,
        destination, socket_base::message_flags(0));
  }
```

í˜„ì¬ë¡œì„œ ì˜ì‹¬ì´ ë˜ëŠ” ë¶€ë¶„ì€ UDP íŒ¨í‚·ì„ ì „ì†¡í•˜ê¸° ìœ„í•´ì„  ì§€ì •í•œ í¬ê¸°ì˜ ë²„í¼ë¥¼ ì†¡ìˆ˜ì‹ í•´ì•¼ í•˜ëŠ”ë° ì§€ì •í•œ í¬ê¸°ì˜ ë‚´ìš©ì´  í•´ë‹¹ ë‚´ìš©ì„ ì´ìŠˆë¡œ ë‚¨ê²¨ë†”ì•¼ ê² ë‹¤.

<img src="https://user-images.githubusercontent.com/45554623/137267438-4ad91ef3-a0d4-4b6b-b779-897914a500a9.png">



## 2021-10-13 c++ object ownership -- ê³„ì†

C++ì˜ ê°ì²´ì§€í–¥ì ì¸ ì„±ê²©ì€ ì˜¤ë¸Œì íŠ¸ ì†Œìœ ê¶Œì—ë„ ì˜ ë“œëŸ¬ë‚˜ìˆë‹¤. êµ¬ê¸€ë§ì„ í•˜ë‹¤ê°€ ì—¬ëŸ¬ ì „ë¬¸ê°€ë“¤ì´ ì‘ì„±í•œ C++ ìì› ëª¨ë¸ ì‘ì„±ì‹œ ë„ì›€ë  ë§Œí•œ ê²ƒì„ ì°¾ì•˜ë‹¤. [resource-model pdf](https://www.stroustrup.com/resource-model.pdf) ë‚˜ì¤‘ì— ì´ì— ëŒ€í•´ ì‘ì„±í•œ ê²ƒì„ ë”°ë¡œ ì˜¬ë¦´ ì˜ˆì •ì´ë‹¤. 

boost-asio-network-clientì˜ login_clientëŠ” ì§€ê¸ˆ(2021-10-13)ìœ¼ë¡œì„  ì‚¬ìš©ì ì…ë ¥ì´ ë°œìƒí•˜ëŠ” í´ë¼ì´ì–¸íŠ¸ í”„ë¡œê·¸ë¨ ì…ì¥ì—ì„œì˜ ë„¤íŠ¸ì›Œí¬ ë‹´ë‹¹ìë¼ê³  í•  ìˆ˜ ìˆë‹¤. í•´ë‹¹ ì¸ìŠ¤í„´ìŠ¤ëŠ” ì—¬ëŸ¬ê°œì˜ connection(sessionê³¼ ë™ì¼)ì„ ì†Œìœ í•  ìˆ˜ ìˆìœ¼ë©° ê° connectionì€ ì„œë²„ì™€ í†µì‹ í•˜ë‹¤ê°€ íŠ¹ì • ë©”ì‹œì§€ë¥¼ ìˆ˜ì‹ í•˜ë©´ login_clientì— ì´ë²¤íŠ¸ë¥¼ ë°œìƒì‹œí‚¨ë‹¤. ê·¸ë ‡ë‹¤ë©´ ì–´ë–»ê²Œ connectionì„ ì†Œìœ í•˜ê³  ìˆëŠ” login_client í•¨ìˆ˜ë¥¼ connectionì—ì„œ ì ‘ê·¼í•  ìˆ˜ ìˆì„ê¹Œ?ê°€ C++ ì˜¤ë¸Œì íŠ¸ ì†Œìœ ê¶Œì— ê´€í•œ ì´ì•¼ê¸°ì˜ ì‹œì‘ì´ë‹¤. 

C++11ì—ì„œ ë„ì…ëœ ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°ì˜ ê°œë… ì—­ì‹œ í•´ë‹¹ ì´ì•¼ê¸°ì™€ ì—°ê´€ì´ ë¼ìˆë‹¤.

### 2021-10-14 ì¶”ê°€

ì†Œìœ ê¶Œì˜ ê°œë…ì€ ìƒë‹¹íˆ ì¤‘ìš”í•˜ë‹¤. ë‹¤ë¥¸ ì–¸ì–´ì™€ëŠ” ë‹¬ë¦¬ ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ì´ ì—†ëŠ” C++ëŠ” í”„ë¡œê·¸ë˜ë¨¸ì—ê²Œ ë©”ëª¨ë¦¬ ê´€ë¦¬ë¼ëŠ” ì–‘ë‚ ì˜ ê²€ì„ ì¥ì–´ì¤¬ìœ¼ë‹ˆê¹Œ. ê·¸ëŸ°ë§Œí¼ ë‹¤ì–‘í•œ ì—°êµ¬ê°€ ì§€ì†ëê³  ìŠ¤ë§ˆíŠ¸ í¬ì¸í„°ëŠ” ê·¸ì¤‘ í•˜ë‚˜ì´ë‹¤. 

ì—¬ë‹´ìœ¼ë¡œ ì–´ëŠ ëˆ„êµ°ê°€ëŠ” autoì™€ template, ìŠ¤ë§ˆíŠ¸í¬ì¸í„°ì™€ ê°™ì´ ìµœê·¼ ë„ì…ëœ ì‹ ê¸°ìˆ ì— ëŒ€í•´ íšŒì˜í•˜ëŠ” ê²½ìš°ë„ ë´¤ë‹¤. ISO C++ í‘œì¤€ ìœ„ì›íšŒ ê°™ì€ ê³³ì—ì„œ ê²€ì¦í•˜ê³  ì¸ì •í•œ í‘œì¤€ ê¸°ìˆ ì— ëŒ€í•´ ë°˜ëŒ€ ì˜ê²¬ì„ ë‚´ë†“ì„ ìˆ˜ ìˆëŠ” ìˆ˜ì¤€ì´ ì•„ë‹Œ ë‚˜ë¡œì„  ì‚¬ìš©í•˜ê¸° í¸ë¦¬í•œ ê¸°ìˆ ì€ ë°˜ê°€ìš´ ì¼ì´ë‹¤. 

ì•„ë¬´íŠ¼ ì†Œìœ ê¶Œì˜ ê°œë…ì€ ê°ì²´ì˜ ìƒì„±ê³¼ íŒŒê´´ë¥¼ ë‹¤ë£¨ê³  ì´ëŠ” í”„ë¡œê·¸ë¨ì˜ ì„±ëŠ¥ì„ ì¢Œìš°í•˜ëŠ” ì¤‘ëŒ€í•œ ì¼ì´ê¸° ë•Œë¬¸ì— C++ í”„ë¡œê·¸ë˜ë¨¸ë¼ë©´ í•„ìˆ˜ì ìœ¼ë¡œ ê³ ë ¤í•´ì•¼í•˜ëŠ” ì‚¬í•­ì´ë‹¤. ê²½í—˜ì´ ì ì€ ì§€ê¸ˆì˜ ë‚˜ëŠ” ë¬´ì¡°ê±´ ë¶€ë”ªí˜€ë³¼ ì˜ˆì •ì´ë‹¤. ğŸ˜



## 2021-10-13 ë¬¸ì œì  #1 -- ê³„ì†

login_server ì…ì¥ì—ì„œ ìƒˆë¡œìš´ ì—°ê²°ì´ ìˆìœ¼ë©´ async_acceptë¥¼ í†µí•´ std::shared_ptr<login_conn>ê°€ ìƒì„±ëœë‹¤. í´ë¼ì´ì–¸íŠ¸ì™€ ì—°ê²°ì ì¸ë° ë¡œê·¸ì¸, ë§¤ì¹­ ì‹œì‘, ë§¤ì¹­ ìˆ˜ë½ ë“±ì˜ ë©”ì‹œì§€ë¥¼ ì£¼ê³  ë°›ì„ ìˆ˜ ìˆë‹¤. ë¬¸ì œëŠ” ë©”ì‹œì§€ë¥¼ ë°›ê³  ë‚˜ì„œ ì„œë²„ ì…ì¥ì—ì„œ ë¡œê·¸ì¸ íì™€ ë§¤ì¹­ íë¥¼ ì ‘ê·¼í•˜ëŠ” ê²ƒì´ ê¹Œë‹¤ë¡­ë‹¤. ì„¤ê³„ì™€ êµ¬í˜„ì˜ ë¬¸ì œë¡œ ë³´ì¸ë‹¤.

### í•´ê²°ë²•?

ì•„ì§ ì ìš©í•˜ì§€ ì•Šì•˜ì§€ë§Œ í•´ê²°ì±…ì€ connected_clients_ì—ëŠ” í´ë¼ì´ì–¸íŠ¸ê°€ ì ‘ì†í•˜ëŠ” ì‹œì ì— shared_ptrë¡œ ì €ì¥ì´ ëœë‹¤. ì´ë¥¼ ê°–ê³  ì–´ë–»ê²Œ í•  ìˆ˜ ìˆì§€ ì•Šì„ê¹Œ? 

### 2021-10-14 ì¶”ê°€ 

observer í´ë˜ìŠ¤ê°€ ìˆë‹¤ë©´ ì–´ë–¨ê¹Œ? ì„œë²„ì˜ ìƒíƒœë¥¼ ì²´í¬í•˜ëŠ” ë§ˆì´í¬ë¡œ ì„œë¹„ìŠ¤ í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ì–´ì„œ API ë°©ì‹ìœ¼ë¡œ ì„œë²„ì˜ ë°ì´í„°ë¥¼ ì¶”ì í•˜ëŠ” ì‹œìŠ¤í…œì„ êµ¬ìƒ ì¤‘ì´ë‹¤.



## boost::asio::streambuf ì— ëŒ€í•´

tcp_connectionì—ì„œëŠ” ë‹¤ìŒì˜ ì´ìœ ë¡œ ìµœëŒ€í•œ STLì˜ char vectorë‚˜ char[] ë“±ì˜ ë²„í¼ ì‚¬ìš©ì„ ì¤„ì´ë ¤ê³  í–ˆë‹¤. 

1. í´ë˜ìŠ¤ê°€ ê°–ëŠ” ë³€ìˆ˜ ìµœì†Œí™”
2. ë¹„ë™ê¸° ì“°ê¸°ì˜ ê²½ìš° ë³€ê²½í•  ìˆ˜ ì—†ëŠ” ì°¸ì¡° ì „ë‹¬ë¡œ ì£¼ì†Œì˜ ë°ì´í„°ì™€ í¬ê¸°ë§Œ ì·¨ë“í•˜ë©´ ë˜ê¸° ë•Œë¬¸ì— í•„ìš”ê°€ ì“°ê¸° ë²„í¼ëŠ” í•„ìš”ê°€ ì—†ë‹¤.
3. ë¹„ë™ê¸° ì½ê¸°ì˜ ê²½ìš°ë§Œ boost::asio::streambufë¥¼ ì´ìš©

[ì´ìŠˆ#1](https://github.com/PioneerRedwood/boost-asio-network/issues/1)ì˜ í™•ì¥ì´ë‹¤. ì „ì—ëŠ” char[]ë¡œ ë°›ì•„ì„œ ì²˜ë¦¬ë¥¼ í–ˆì—ˆìœ¼ë‚˜ ë¡œì§ì„ êµ¬ì„±í•  ë•Œ êµ¬ë¶„ìë¡œ '\n' ë¬¸ìë¥¼ ì§€ì •í–ˆê³  ê·¸ì „ê¹Œì§€ ë¹„ë™ê¸°ë¡œ ì½ëŠ” ê²ƒì´ í•„ìš”í–ˆë‹¤. async_read_untilì€ ì´ëŸ¬í•œ ìƒí™©ì—ì„œ í•©ë¦¬ì ì´ì—ˆë‹¤ê³  ìƒê°í•œë‹¤. 

```C++
template <typename AsyncReadStream, typename DynamicBuffer_v1,
    BOOST_ASIO_COMPLETION_TOKEN_FOR(void (boost::system::error_code,
      std::size_t)) ReadHandler>
BOOST_ASIO_INITFN_AUTO_RESULT_TYPE(ReadHandler,
    void (boost::system::error_code, std::size_t))
async_read_until(AsyncReadStream& s,
    BOOST_ASIO_MOVE_ARG(DynamicBuffer_v1) buffers,
    char delim, BOOST_ASIO_MOVE_ARG(ReadHandler) handler,
    typename constraint<
      is_dynamic_buffer_v1<typename decay<DynamicBuffer_v1>::type>::value
    >::type,
    typename constraint<
      !is_dynamic_buffer_v2<typename decay<DynamicBuffer_v1>::type>::value
    >::type)
{
  return async_initiate<ReadHandler,
    void (boost::system::error_code, std::size_t)>(
      detail::initiate_async_read_until_delim_v1<AsyncReadStream>(s),
      handler, BOOST_ASIO_MOVE_CAST(DynamicBuffer_v1)(buffers), delim);
}
```

12ê°œì˜ ì˜¤ë²„ë¡œë“œ í•¨ìˆ˜ ì¤‘ì—ì„œ ì›í•˜ë˜ ê²ƒì„ ì°¾ì•˜ë‹¤. ì´ê²ƒì„ ì ìš©ì€ í•´ì„œ ì‘ë™í•˜ê¸°ë§Œ í™•ì¸í–ˆë‹¤. ë””ë²„ê¹…ê³¼ ë²„í¼ì— ê´€ë ¨ëœ ì—ëŸ¬ê°€ ëœ¨ì§€ëŠ” ì•ŠëŠ”ì§€ ì²´í¬í•˜ëŠ” ê²ƒì€ ê³§ ì§„í–‰í•  ì˜ˆì •ì´ë‹¤.

