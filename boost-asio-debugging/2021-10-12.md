# 2021-10-12 

## 2021-10-08 ë¬¸ì œì  #2 ê³„ì†

```
The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.
```

[boost-asio async_read_until docuemnt](https://www.boost.org/doc/libs/1_77_0/doc/html/boost_asio/reference/async_read_until/overload1.html)ì—ì„œ í•´ë‹¹ ë¬¸ì œì ì˜ ì›ì¸ìœ¼ë¡œ ë³´ì´ëŠ” ê²ƒì„ ì°¾ì•˜ë‹¤. async_read_untilì´ ìˆ˜í–‰ë˜ëŠ” ë™ì•ˆì— ë™ì¼í•œ ìŠ¤íŠ¸ë¦¼ì—ì„œ ë‹¤ë¥¸ async_read ë™ì‘ì„ ìˆ˜í–‰í•˜ì§€ ì•Šì•„ì•¼í•¨ì„ ë³´ì¥í•´ì•¼í•œë‹¤. ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ í•´ë‹¹ ìŠ¤íŠ¸ë¦¼ì—ì„œ ì½ì–´ë‚´ëŠ” ë™ì•ˆ(ì§€ì •í•œ êµ¬ë¶„ì(delimiter)ë¥¼ ì°¾ëŠ” ë¹„ë™ê¸° ì½ê¸°ê°€ ì‹¤í–‰ë˜ê³  ìˆëŠ” ìƒíƒœë¥¼ ë§í•¨)  ì¶©ëŒì´ ì¼ì–´ë‚˜ì„œ ëª» ì°¾ì•„ë‚´ê±°ë‚˜ ì¤‘ê°„ì— ëŠì–´ë²„ë¦´ ìˆ˜ ìˆëŠ” ê²ƒì´ë‹¤. 

ê³¼ì—° ì´ê²ƒì€ ì •í™•í•œ ì›ì¸ì¼ê¹Œ? ë¹„ë™ê¸° ì½ê¸°ëŠ” ëª¨ë‘ strandë¡œ ê°ì‹¸ì„œ ë¹„ë™ê¸° ì‹¤í–‰ì˜ ìˆœì„œë¥¼ ì§€ì •í•˜ê³  ìˆë‹¤. 

```c++
io::async_read(socket_, io::buffer(read_buffer_),
    strand_.wrap(
    [this, self = this->shared_from_this()](const err error, size_t bytes)->void
    {
        // ERROR CHECK
        // DO SOMETHING
    }));
// í˜¹ì€
io::async_read_until(socket_, buffer_, '\n',
	strand_.wrap(
    [this, self = this->shared_from_this()](const err error, size_t bytes)->void
    {
    	// ERROR CHECK
		// 2021-10-10 ë¬¸ì œ ë°œìƒ ì§€ì 
        std::istream in(&buffer_);
        std::string msg;
        std::getline(in, msg);
		
        buffer_.consume(bytes);
        self->on_message(msg);
	}));
```



### ë©°ì¹  ì§¸ ì§„í–‰ì¤‘ì¸ ì´ìŠˆì— ëŒ€í•˜ì—¬

ìˆ˜ë§Œê°œì˜ ì—°ê²°ì´ ì§€ì†ë˜ëŠ” ìƒíƒœì—ì„œ ì–´ë–¤ í´ë¼ì´ì–¸íŠ¸ë¡œë¶€í„° ì–´ë–¤ ë©”ì‹œì§€ê°€ ì˜¬ì§€ ì„œë²„ëŠ” ì „í˜€ ì˜ˆì¸¡í•  ìˆ˜ ì—†ë‹¤. ì–´ë–¤ ë©”ì‹œì§€ê°€ ì˜¤ë“  ì²˜ë¦¬ë¥¼ í•´ì•¼í•˜ëŠ” ì„œë²„ ì…ì¥ì—ì„œ ì•ˆì •ì„±ì€ ê°€íˆ ê°€ì¥ ì¤‘ìš”í•˜ë‹¤ê³  ë§í•  ìˆ˜ ìˆë‹¤. í—Œë° ì§€ê¸ˆ TCPì—°ê²°ì—ì„œ ì´ëŸ¬í•œ ì•ˆì •ì„±ì´ ê²°ì—¬ëœ ì´ìŠˆëŠ” ì¹˜ëª…ì ì´ë‹¤. ì–´ë–»ê²Œ í•´ê²°í•  ìˆ˜ ìˆì„ê¹Œ?



## íŒ¨í‚· ì„¤ê³„

íŒ¨í‚· ì„¤ê³„ëŠ” ì–¸ì  ê°€ëŠ” í•´ì•¼í•  ì¼ì´ë‹¤. Googleì˜ Protocol Bufferë¥¼ ì‚¬ìš©í•˜ê³  ì‹¶ì—ˆì§€ë§Œ í”„ë¡œì íŠ¸ì— ë„£ëŠ” ê²ƒë¶€í„° ì•ˆë¼ì„œ ê³„ì† ë¯¸ë¤„ë‘ê³  ìˆì—ˆë‹¤.



## timeoutì˜ ì¤‘ìš”ì„±

ë¹„ë™ê¸° ëª…ë ¹ ì²´ì¸ì€ boost-asioì˜ io_contextê°€ ì‚´ì•„ë‚¨ê¸° ìœ„í•´ í•„ìš”í•œ ê²ƒì´ë‹¤. ì˜ë„ì ìœ¼ë¡œ timeoutì„ ë§Œë“¤ ìˆ˜ë„ ìˆì§€ë§Œ ë§Œì•½ io_contextì— ë“±ë¡ëœ ë¹„ë™ê¸° ëª…ë ¹ì´ ì—†ë‹¤ë©´ io_context ëŠ” ë”ì´ìƒ ìœ íš¨í•˜ì§€ ì•Šê²Œ ëœë‹¤. 

ë¬´ë¶„ë³„í•œ timer ìƒì„± í˜¹ì€ ì˜ˆìƒí•˜ì§€ ëª»í•˜ëŠ” ë¹„ë™ê¸° ëª…ë ¹ ì²´ì¸ì€ io_contextë¥¼ ì˜ˆìƒì¹˜ ëª»í•œ ë°©í–¥ìœ¼ë¡œ ì´ëŒì–´ê°ˆ ìˆ˜ ìˆìœ¼ë©° ì´ëŠ” ê²°ê³¼ì ìœ¼ë¡œ ì–´í”Œë¦¬ì¼€ì´ì…˜ì´ ì˜ˆìƒì¹˜ ëª»í•œ ê³³ì—ì„œ ì£½ëŠ” ìƒí™©ì„ ë§Œë“¤ ìˆ˜ ìˆë‹¤.



## udp_server/client

UDP ì†Œì¼“ì„ ì‚¬ìš©í•˜ëŠ” ì„œë²„ì™€ í´ë¼ì´ì–¸íŠ¸ì´ë‹¤. ì•„ì§ ì„¤ê³„ê°€ ëª…í™•í•˜ì§„ ì•Šì§€ë§Œ ë¨¸ë¦¿ì†ì—ì„œ ê·¸ë ¤ì§€ëŠ” íë¦„ëŒ€ë¡œ ìš°ì„  ì‘ì„±í•´ë´¤ë‹¤. TCPì™€ í° ì°¨ì´ì ì€ ëª…ì‹œì ìœ¼ë¡œ ì—°ê²°ì„ ìš”ì²­í•˜ê±°ë‚˜ ìˆ˜ë½í•˜ëŠ” ë¶€ë¶„ì´ ì—†ë‹¤ëŠ” ê²ƒì´ë‹¤.

udp_server

- io_context ì°¸ì¡° ê°ì²´ì™€ port ë²ˆí˜¸ë§Œ ì§€ì •í•´ì£¼ë©´ ì—°ê²° ìˆ˜ë½ì´ ì—†ì´ ë¹„ë™ê¸°ë¡œ ì…ë ¥ì„ ë°›ì„ ë•Œë§ˆë‹¤ ì²˜ë¦¬í•œë‹¤.
- ì„œë²„ì—ì„œ ì¼ì • ì£¼ê¸°ë§ˆë‹¤ í´ë¼ì´ì–¸íŠ¸ì— ë°ì´í„°ë¥¼ ë³´ë‚´ëŠ”ê²Œ ë§ì„ ë“¯ í•˜ë‹¤.

udp_client

- io_context ì°¸ì¡° ê°ì²´, ë©”ì‹œì§€ ì „ì†¡ ì£¼ê¸°, ì£¼ì†Œì™€ port ë²ˆí˜¸ë§Œ ì§€ì •í•´ì£¼ë©´ ì—°ê²° ì—†ì´ ë¹„ë™ê¸°ë¡œ ë°ì´í„°ë¥¼ ë³´ë‚¸ë‹¤.
- í´ë¼ì´ì–¸íŠ¸ì— ë©”ì‹œì§€ ì „ì†¡ ì£¼ê¸°ëŠ” í•„ìš”ê°€ ì—†ë‹¤.

- mainì—ì„œ [Windows Console Input](https://docs.microsoft.com/en-us/windows/console/reading-input-buffer-events) í…ŒìŠ¤íŠ¸ë¡œ í‚¤ë³´ë“œì˜ ì…ë ¥ì„ ë³´ë‚´ëŠ” ë°©ì‹ìœ¼ë¡œ ì§„í–‰.

  - **ê°‘ì‘ìŠ¤ëŸ½ê²Œ ì¢…ë£Œë˜ëŠ” ë¬¸ì œì  ë°œìƒ**, ì¶”ì •í•˜ê³  ìˆëŠ” ê²ƒì€ ì—¬ì „íˆ TCPì—ì„œë„ ì§„í–‰í–ˆë“¯ í‚¤ë³´ë“œ ì…ë ¥ì´ ë¹„ë™ê¸° ì „ì†¡ ëª…ë ¹ì„ ì¤‘ë³µì ìœ¼ë¡œ ì „ì†¡í•˜ê²Œ ë˜ë©´ì„œ í˜¸ì¶œì— ì¶©ëŒì´ ì¼ì–´ë‚˜ëŠ” ê²ƒ. **ì´ê±¸ ì–´ë–»ê²Œ ë””ë²„ê¹…í•  ìˆ˜ ìˆì„ê¹Œ?**

    - í•´ê²° .. ì¹´ìš´íŠ¸ë¥¼ 100ë²ˆë§Œ ëŒë„ë¡ í–ˆì—ˆìŒ, ì¶”ì •ê³¼ëŠ” ë‹¤ë¥¸ ë¬¸ì œì ì´ì—ˆë‹¤. ğŸ˜’ğŸ¤¦â€â™‚ï¸

    

#### ì˜ë¬¸ì  ğŸ¤”

udp::socketì˜ async_send_to() ì „ì†¡ ì‹œ ë¹„ë™ê¸° ì“°ê¸° ì´í›„ ì „ì†¡í•œ ë°”ì´íŠ¸ì˜ í¬ê¸°ê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì „ë‹¬í•œ ë©”ì‹œì§€ì˜ í¬ê¸°ì™€ ë‹¤ë¥´ë‹¤. 

```C++
/// Start an asynchronous send.
  /**
   * This function is used to asynchronously send a datagram to the specified
   * remote endpoint. The function call always returns immediately.
   *
   * @param buffers One or more data buffers to be sent to the remote endpoint.
   * Although the buffers object may be copied as necessary, ownership of the
   * underlying memory blocks is retained by the caller, which must guarantee
   * that they remain valid until the handler is called.
   *
   * @param destination The remote endpoint to which the data will be sent.
   * Copies will be made of the endpoint as required.
   *
   * @param handler The handler to be called when the send operation completes.
   * Copies will be made of the handler as required. The function signature of
   * the handler must be:
   * @code void handler(
   *   const boost::system::error_code& error, // Result of operation.
   *   std::size_t bytes_transferred           // Number of bytes sent.
   * ); @endcode
   * Regardless of whether the asynchronous operation completes immediately or
   * not, the handler will not be invoked from within this function. On
   * immediate completion, invocation of the handler will be performed in a
   * manner equivalent to using boost::asio::post().
   *
   * @par Example
   * To send a single data buffer use the @ref buffer function as follows:
   * @code
   * boost::asio::ip::udp::endpoint destination(
   *     boost::asio::ip::address::from_string("1.2.3.4"), 12345);
   * socket.async_send_to(
   *     boost::asio::buffer(data, size), destination, handler);
   * @endcode
   * See the @ref buffer documentation for information on sending multiple
   * buffers in one go, and how to use it with arrays, boost::array or
   * std::vector.
   *
   * @par Per-Operation Cancellation
   * On POSIX or Windows operating systems, this asynchronous operation supports
   * cancellation for the following boost::asio::cancellation_type values:
   *
   * @li @c cancellation_type::terminal
   *
   * @li @c cancellation_type::partial
   *
   * @li @c cancellation_type::total
   */
  template <typename ConstBufferSequence,
      BOOST_ASIO_COMPLETION_TOKEN_FOR(void (boost::system::error_code,
        std::size_t)) WriteHandler
          BOOST_ASIO_DEFAULT_COMPLETION_TOKEN_TYPE(executor_type)>
  BOOST_ASIO_INITFN_AUTO_RESULT_TYPE(WriteHandler,
      void (boost::system::error_code, std::size_t))
  async_send_to(const ConstBufferSequence& buffers,
      const endpoint_type& destination,
      BOOST_ASIO_MOVE_ARG(WriteHandler) handler
        BOOST_ASIO_DEFAULT_COMPLETION_TOKEN(executor_type))
  {
    return async_initiate<WriteHandler,
      void (boost::system::error_code, std::size_t)>(
        initiate_async_send_to(this), handler, buffers,
        destination, socket_base::message_flags(0));
  }
```

í•´ê²°ì´ í•„ìš”í•˜ë‹¤