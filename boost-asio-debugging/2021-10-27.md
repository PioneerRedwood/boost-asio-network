# 2021-10-27 디버깅 일지

[jacking75](https://github.com/jacking75)님의 깃허브를 통해 많은 공부를 하고 있다. 👍 아무래도 지엽적으로만 했던 코딩을 업그레이드할 때가 온것 같다. 

#### 진행 중

user, user_manager, lobby, lobby_manager 등 서버에서 런타임 인스턴스로 쓸 클래스를 구현하고 있다.

소켓을 사용하고 boost-asio를 사용하는 network connect session들을 만들다보니 겹치는 코드가 상당하다. 사실 이런 모습들은 초창기(그래봐야 boost-asio를 접한 21년 9월임) 전부터 보였다. 그래서 그냥 상속 구조를 사용해도 괜찮을 것 같다고 생각하고 tcp_connection이라는 이름의 클래스를 만든적이 있다. 그래서 서버 클래스내에 있는 session 클래스들은 다 tcp_connection의 원형과 매우 흡사하다.



#### 로비 접속 

lobby에 접속하는 것은 됐다. 예전부터 느낀 거지만 데이터를 직렬화, 역직렬화하는 과정은 고달프다... 한번 하면 참 좋을텐데... 이젠 할 차례다...

<img src="https://user-images.githubusercontent.com/45554623/139030482-5c6aa219-35ff-46f2-b310-bcb4436744b1.png">

로비에서 나가고 나서 서버에서의 처리가 원활하지 않다. 서버에서 stop()함수에 해당 아이디를 없애버리는 것을 하고 있는데 될 때도 있고 안될 때도 있는 현상이 발생하는데 다시 수정해야겠다.

클라이언트에서도 자신이 속한 로비가 무엇인지 알 수 있어야 하고 서버에서도 해당 session_id가 어디 로비에 속했는지 혹은 아닌지 알아야한다. 이에 대해선 개선점이 필요하다.



#### 추가된 부분

며칠전 로그인 씬에서 로비 씬으로 넘어오며 통신하는 것을 테스트했다. 로그인은 RESTful API 서버의 응답을 원활하게 받은 경우 이 씬이 로드되고 씬이 변경되는 이벤트가 발생할 때 로비 클라이언트가 새롭게 서버에 접속하는 것으로 했다. 아래는 간단한 UI 오른쪽은 유저의 데이터가 담길 것이며 왼쪽은 로비 리스트와 로비에 있는 유저들의 상태를 볼 수 있을 것이다. 지금까지 진행한 것으로 보아 로비는 일종의 대기실 같은 개념으로 사용된다. 

Refresh 버튼은 서버에 로비 리스트에 대한 정보를 요청, Join #1 버튼은 유저의 세션 아이디와 로비 인덱스를 바탕으로 서버에 접속 요청을 보낸다. 성공적이면 entering [lobby_index] success가 반환된다. 

구상했던 것은 로비 역시 MySQL DB 혹은 redis 인메모리 DB에 CRUD하는 형태로 하려고 했는데 지금은 런타임 인스턴스로 서버에서 관리하도록 한다. 프로토타입 개발 방식이라 되는대로 진행하고 나중에 다듬을 예정이다. 

<img src="https://user-images.githubusercontent.com/45554623/139074602-d6775c75-55d3-4e24-a136-508c346c3159.png">

<img src="https://user-images.githubusercontent.com/45554623/139074363-945e8e80-7fda-4254-ac52-996e1c4d4180.png">



#### 진행 예정

로비에 N명이 차게 되면 게임이 시작되는 시스템을 만들어야 한다. 게임은 UDP로 통신할 예정이다. 동적으로 게임을 생성 -> 진행 -> 파괴 등을 모두 정상적으로 처리해야한다.