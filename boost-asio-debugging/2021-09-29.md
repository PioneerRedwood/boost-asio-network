## 2021-09-29 #2

#### 문제점 #1

- 클라이언트에서 서버로 메시지를 전송 작업이 수행이 되고 서버에선 받은 메시지를 콘솔에 출력한다. 그 즉시 서버는 받은 메시지에 따라 클라이언트에 적절한 메시지를 전송한다. 
- 여기서 서버로부터 수신된 메시지의 형태가 매우 이상하다.

#### 디버깅

- 클라이언트에서 수신된 메시지를 읽는 부분에서는 on_read_completion()이라는 함수로 "\n" 문자가 올 때까지 읽는데, 무작위로 코드를 수정하다가 서버에서 비동기 쓰기 함수에서 보내는 내용 끝에 "\n" 문자를 붙이는 것을 삭제했다. 



#### ~~문제점 #2~~

- ~~설계상 클라이언트는 키보드 입력에 따라 서버에 전송하는 메시지가 다르다. 서버에서 수신은 빠른데 다시 돌아오는 응답에는 딜레이가 있다.~~

#### ~~문제점 #3~~

- ~~클라이언트 연결이 5-6개 됐을 때 알 수 없는 오류로 인해 종료될 수 있다.~~



#### 문제점 #4

- 서버와 클라이언트 양쪽 모두 boost::asio::io_context(이하 io_context) 인스턴스의 run() 함수를 실행할 스레드를 어디에 만드는게 적합할까?
  - 현재 방식에서 서버는 서버 인스턴스를 생성하는 main 함수에서 io_context 객체를 참조 전달해서 생성하여 서버 인스턴스 내부에 있는 스레드로 참조 전달된 io_context 객체의 run()을 호출한다. 클라이언트 역시 동일한 방식으로 수행하지만 클라이언트에서는 무한 루프로 연결이 종료되기까지 사용자의 키보드 입력에 따라 서버에 데이터를 전송한다. 
  - 곧바로 종료됨, io_context의 참조가 전달된 boost::asio::steady_timer가 있는데도 종료됨

#### 디버깅

- 서버는 종료되고 클라이언트는 종료되지 않는 이유는 그 둘의 차이점에 있다. 클라이언트는 main 함수 내에 일정 조건에 의해 끝나는 무한 루프 작업이 존재하기 때문에 스레드가 종료되지 않는다.
- io_context가 존재하는 main 내에서 더이상의 작업이 없는 경우 main 스레드가 종료되면서 프로그램 내 스레드는 모두 종료된다. 이로 인해 서버는 아무리 io_context에 비동기 호출이 존재한다해도 종료되는 것이다.



#### 문제점 #5

- 서버/클라이언트의 소켓 및 버퍼 래퍼 클래스인 connection에서 on_message() 내부에서 수신된 메시지를 1차적으로 처리해서 수신 메시지 덱에 저장하고 일정 주기마다 수신 덱을 점검하는 서버/클라이언트의 update()에서 2차적으로  처리한다.
- 과연 이 구조가 합리적일까? 전문가에게 물어보자



#### 문제점 #6

- 현재 서버 측에 세션 룸 생성 요청 시 처리하는 과정에서 엑세스 위반 예외를 마주했다. - std::unique_ptr 사용으로 해결했으나 설계가 여전히 마음에 안듬
- 세션 룸을 생성하고 나서 조회까지는 가능하지만 세션을 소유하고 있는 클라이언트 종료시 다른 클라이언트까지 종료하는 버그 발견
